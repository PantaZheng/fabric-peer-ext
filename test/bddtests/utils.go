/*
Copyright IBM Corp. 2016 All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

		 http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/*
Copyright SecureKey Technologies Inc. All Rights Reserved.

SPDX-License-Identifier: Apache-2.0
*/

package bddtests

import (
	"crypto/rand"
	"fmt"
	"io"

	"github.com/ipfs/go-cid"
	dshelp "github.com/ipfs/go-ipfs-ds-help"
	mh "github.com/multiformats/go-multihash"
)

// GenerateBytesUUID returns a UUID based on RFC 4122 returning the generated bytes
func GenerateBytesUUID() []byte {
	uuid := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, uuid)
	if err != nil {
		panic(fmt.Sprintf("Error generating UUID: %s", err))
	}

	// variant bits; see section 4.1.1
	uuid[8] = uuid[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuid[6] = uuid[6]&^0xf0 | 0x40

	return uuid
}

// GenerateUUID returns a UUID based on RFC 4122
func GenerateUUID() string {
	uuid := GenerateBytesUUID()
	return idBytesToStr(uuid)
}

func idBytesToStr(id []byte) string {
	return fmt.Sprintf("%x-%x-%x-%x-%x", id[0:4], id[4:6], id[6:8], id[8:10], id[10:])
}

const (
	// The go-ipfs-blockstore library that is being used for DCAS
	// always prefixes the key with "/blocks"
	dsPrefix = "/blocks"
)

// getCASKey returns the key which will be used in the data store to store the value.
func getCASKey(content []byte) (string, error) {
	cID, err := getCID(content, CIDV1, cid.Raw, mh.SHA2_256)
	if err != nil {
		return "", err
	}

	return dsPrefix + dshelp.NewKeyFromBinary(cID.Bytes()).String(), nil
}

// CIDVersion specifies the version of the content ID
type CIDVersion = uint64

const (
	CIDV0 CIDVersion = 0
	CIDV1 CIDVersion = 1
)

func getCID(content []byte, version CIDVersion, codec, mhType uint64) (cid.Cid, error) {
	var b cid.Builder

	switch version {
	case CIDV1:
		b = cid.V1Builder{
			Codec:  codec,
			MhType: mhType,
		}
	case CIDV0:
		b = cid.V0Builder{}
	default:
		return cid.Cid{}, fmt.Errorf("unsupported CID version [%d]", version)
	}

	c, err := b.Sum(content)
	if err != nil {
		return cid.Cid{}, err
	}

	return c, nil
}
